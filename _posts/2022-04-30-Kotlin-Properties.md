---
layout: post
title:  Kotlin for Java Developers - Properties
date:   2022-04-30 14:22 +0900
categories: TIL
---


## Properties

### TOC
1. [Properties](#1-properties)
2. [More about Properties](#2-more-about-properties)
3. [Lazy or late initialization](#3-lazy-or-late-initialization)
4. [TMI](#4-tmi)

### 1. Properties
`Unlike Java where a property is not a language construct, Kotlin supports it as a separate language feature.`

처음 코틀린의 프로퍼티 개념을 접했을 때 자바의 필드와 제대로 구분하지 못해서 관련 내용을 이해하는 데 어려움을 겪었다.
코틀린에서 말하는 프로퍼티란 무엇이고 자바의 필드와 어떻게 다른지 분명히 정리해보자.

코틀린의 프로퍼티는 자바의 필드에 접근자까지 더한 개념이다.

```
Kotlin: property
Java: field + accessors(getter, setter)
```

`You define the property itself rather than separately fields and accessors.`

자바에서 프로퍼티를 정의해보고, 코틀린에서 프로퍼티를 정의한 뒤 비교해보자.

```java
// foo + getFoo + setFoo = foo property
public class JavaClass {
    // 자바에서는 프로퍼티를 직접 정의할 수 없다.
    private int foo = 0;
    public int getFoo() { return foo; }
    public void setFoo(int foo) { this.foo = foo; }
}
```
```kotlin
class KoltinClass {
    // 코틀린에서는 프로퍼티 자체를 정의할 수 있다
    var foo = 0
}
```

`val`과 `var` 키워드는 프로퍼티를 정의할 때 쓰인다.
각 키워드가 만드는 프로퍼티를 필드와 접근자로 나누면 다음과 같다.

```
property = field + accessor(s)
val = field + getter
var = field + getter + setter
```

코틀린에서 프로퍼티를 사용하면, getter 또는 setter를 호출하지 않고 프로퍼티를 변수처럼 직접적으로 사용하고 접근할 수 있다.
이름을 통해 프로퍼티에 접근하면 내부적으로 getter가 호출된다. 마찬가지로, 변수를 대하듯 직접 프로퍼티의 값을 수정하면, 내부적으로 setter가 호출된다.

```kotlin
class Person {
    var name = 0
}

fun main() {
    val person = Person()
    person.name = "john"; // call setter
    println(person.name) // call getter
}
```

클래스 밖에서 프로퍼티를 사용할 경우 내부적으로는 접근자가 호출된다.
클래스 안에서 프로퍼티를 사용할 경우 해당 프로퍼티가 전형적인 프로퍼티라면 접근자를 이용하지 않고
직접 필드에 접근하도록 컴파일러에 의해 최적화가 이루어진다.

**<u>Properties without fields</u>**

```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {
            return height == width
        }
}

val rectangle = Rectangle(2, 3)
println(rectangle.isSquare) // false
```

`isSquare`는 필드 없이 getter만 가지고 있는 프로퍼티이다. 접근할 때마다 계산하면 되므로 값을 필드에 저장해둘 필요가 없다.

**<u>Fields</u>**

`In Kotlin, you don’t work with fields directly, you work with properties.`

`You can access field only inside accessors by using the field keyword.
It’s not visible for other methods of the class.`

```kotlin
class StateLogger {
    var state = false
        set(value) {
            // field is keyword in accessors
            println("state has changed: " + "$field -> $value")
            field = value
        }
}
```

**<u>No backing fields</u>**

접근자를 재정의하고 그 안에서 `field` 키워드를 쓰지 않는다면 컴파일러는 backing 필드를 생성하지 않는다.

```kotlin
enum class State { ON, OFF }

class StateLogger {
    private var boolState = false

    // state의 accessor에서 field 키워드를 사용하지 않고 있으므로
    // state를 위한 backing field는 생성되지 않는다
    var state: State
        get() = if (boolState) ON else OFF
        set(value: State) {
            boolState = value == ON
        }
}
```

만약 접근자를 재정의하지 않는다면 컴파일러가 전형적인 접근자를 생성하는데,
이 전형적인 접근자에서 `field` 키워드를 사용하므로 backing field가 생성된다.

```kotlin
class A {
    
    var trivialProperty: String = "abc"
        get() = field // generated by compiler
        set(value: String) { // generated by compiler
            field = value
        }
    
}
```

**<u>Accessors visibility</u>**

때때로 `var` 프로퍼티를 클래스 외부에서는 read-only로만 접근하게 하고 싶을 때가 있다.
다음과 같이 setter를 `private`으로 만들면 외부에서만 read-only로 접근하게끔 할 수 있다.

```kotlin
class LengthCounter {
    var counter: Int = 0
        private set

    fun addWord(word: String) {
        counter += word.length // counter is mutable in class
    }
}

fun main() {
    val lengthCounter = LengthCounter()
    lengthCounter.counter += 1 // compile error
}
```

### 2. More about Properties

**<u>Property in interface</u>**

인터페이스에 프로퍼티를 설정할 수 있다.

`under the hood, it’s just a getter`

```kotlin
interface User {
    val nickname: String
}

class FacebookUser(val accountId: Int) : User {
    override val nickname = getFacebookName(accountId)
}

class SubscribingUser(val email: Int) : User {
    override val nickname: String
        get() = email.substringBefore('@')
}
```

인터페이스의 모든 프로퍼티는 `open`(not final)이며 smart cast될 수 없다.
프로퍼티가 `open`일 경우 하위 클래스에서 구현할 때 커스텀 getter를 가질 수 있는데,
프로퍼티가 커스텀 getter를 가지면 매 접근마다 다른 값을 반환할 수 있기 때문이다. (캐스팅 후에 같은 값을 줄거라는 보장이 없다.)

```kotlin
interface Session {
    val user: User
}

fun analyzeUserSession(session: Session) {
    if (session.user is FacebookUser) {
        println(session.user.accountId) // compile error
    }
}
```

아래와 같이 지역 변수를 사용하면 이 문제를 해결할 수 있다.

```kotlin
fun analyzeUserSession(session: Session) {
    val user = session.user // 이때의 값을 user에 담아두기 때문에 항상 같은 값을 반환하는 것이 보장됨
    if (user is FacebookUser) {
        println(user.accountId)
    }
}
```

Smart cast는 mutable 프로퍼티에 대해 적용되지 않는다.
Mutable 프로퍼티는 특정 타입임을 확인한 후에도 다른 스레드에 의해 값이 변할 수 있기 때문이다.

```kotlin
class Session {
    var user: User? = null
}


fun analyzeUserSession(session: Session) {
    if (session.user is FacebookUser) {
        println(session.user.accountId) // compile error
    }
}
```

`Smart cast to 'FacebookUser' is impossible, because 'session.user' is a mutable property that could have been changed by this time`

**<u>Extension properties</u>**

문법은 extension 함수와 유사하다.

```kotlin
val String.lastIndex: Int
    get() = this.length - 1

val String.indices: IntRange
    get() = 0..lastIndex

"abc".lastIndex // 2
"abc".indices // 0..2
```

원리도 유사하다. Extension 프로퍼티는 결국 receiver 타입의 인자가 추가된 `static` 접근자이다.

### 3. Lazy or late initialization

**<u>Lazy property</u>**

Lazy 프로퍼티는 처음 프로퍼티에 접근할 때(필요해졌을 때) 초기화되는 프로퍼티이다.
결과가 실제로 필요한 순간까지 아무일도 하지 않는다는 관점에서 lazy라고 본다.

Lazy 프로퍼티는 `by lazy` 문법을 통해 만들 수 있다.

```kotlin
val lazyValue: String by lazy {
    print("computed! ")
    "Hello"
}

fun main() {
    println(lazyValue) // computed! Hello
    println(lazyValue) // Hello
}
```

`lazy`는 람다를 인자로 받는 함수이다. 람다 안에서 해당 프로퍼티에 저장하고 있어야 할 값을 계산한다.

**<u>lateinit</u>**

프로퍼티를 생성자에서 초기화하지 않고 다른 때 초기화하고 싶을 때가 있다.
이럴 때는 초깃값이 없기 때문에 프로퍼티를 non-nullable로 타입으로 선언할 수 없다.
따라서 nullable 타입으로 선언해야 하고, 매번 이 프로퍼티를 사용할 때마다 safe access 문법을 이용해야 한다.
적절하게 초기화된다면 `null`일 수 없는 프로퍼티임에도 말이다.

```kotlin
class KotlinActivity: Activity() {
    var myData: MyData? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        myData = intent.getParcelableExtra("MY_DATA")
    }
    
    ... myData?.foo ...
}
```

이럴 때 `lateinit` 프로퍼티를 사용한다. `lateinit` 프로퍼티를 사용하면 non-nullable 타입이면서 생성자가 아닌 곳에서,
객체가 생성되는 시점이 아닌 다른 시점에 프로퍼티가 초기화되게 할 수 있다.

만약 `lateinit` 프로퍼티가 제대로 초기화되지 않았는데 사용할 경우 `UninitializedPropertyAccessException`이 던져진다.

**<u>lateinit constraints</u>**

`lateinit` 프로퍼티는 `val`일 수 없다. `lateinit` 프로퍼티가 `val`이어도 바이트코드 레벨에서 `final`이 아니므로
자바로 변환하고 보면 값을 변경할 수 있는 것처럼 보인다. 다시 말해 `lateinit` 프로퍼티가 `val`일 경우 코틀린에서는 immutable이나
자바로 변환시 mutable이므로(바이트코드 레벨에서 `final`이 아니므로) 혼란이 생긴다.

- `lateinit` 프로퍼티의 타입은 nullable일 수 없다. Nullability 이슈를 다루고 싶었으면, nullable 타입이 괜찮았으면 `lateinit`이 굳이 필요 없지 않을까.
- `lateinit` 프로퍼티의 타입은 primitive일 수 없다. Primitive 타입의 경우 초기화되지 않았음을 나타낼 수 있는 값이 없기 때문이다.
정수인 경우 0을 초기화되지 않은 값 삼을 수 있겠지만, 초기화 결과가 0인 경우도 분명 있을 수 있다.
만약 프로젝트의 특성상 정수의 초기화 결과가 0이 될 수 없다면 코틀린이 아닌 그 프로젝트의 개발자가 직접 0으로 초기화 하면 된다. 아래 글을 참고하자.

https://stackoverflow.com/questions/57408327/does-kotlin-have-primitive-types
https://stackoverflow.com/questions/49594089/why-cant-i-set-lateinit-for-a-int-var-in-kotlin

**<u>Checking whether lateinit var was initialized</u>**

프로퍼티 레퍼런스에서 `isInitialized()`를 호출하면 `lateinit` 프로퍼티가 초기화됐는지 아닌지를 검사할 수 있다.

```kotlin
class MyClass {
    lateinit var lateinitVar: String

    fun initializationLogic() {
        println(::lateinitVar.isInitialized) // false
        lateinitVar = "value"
        println(::lateinitVar.isInitialized) // true
    }
}
```

`::`가 없으면 `isInitialized`를 호출할 수 없다. 이는 프로퍼티 레퍼런스와 관련된 내용인데, 아래 글을 참고하자.

https://kotlinlang.org/docs/reflection.html#property-references

### 4. TMI

**<u>Backing fields</u>**

https://kotlinlang.org/docs/properties.html#backing-fields

코틀린에서 필드는 오직 property의 값을 메모리에 저장하기 위해 property의 일부로만 사용된다.
필드를 직접 선언할 수는 없다. 하지만 property가 backing field를 필요로 할 경우 코틀린이 자동으로 제공한다. Backing field는 property의 accessors 안에서 `field`를 통해 레퍼런스될 수 있다.

Backing field는 property가 적어도 하나 이상의 accessor에 대해 기본 구현을 쓰거나 커스텀 accessor에서 `field`라는 키워드를 통해 필드에 접근하는 경우 자동으로 생성된다.

**<u>클래스 밖에서는 항상 accessor를 통해 property에 접근하는 이유</u>**

왜 클래스 밖에서는 항상 내부적으로 accessors를 이용해 접근하도록 구현되었을까? 클래스 A에 a라는 property가 있고 클래스 A의 외부에서 a 프로퍼티의 필드에 직접 접근하도록 최적화되었다고 가정해보자. 만약 getter의 구현이 바뀌어야 한다면? A의 a에 접근할 때 새롭게 구현된 getter를 사용하도록 A를 사용하는 모든 코드를 다시 컴파일해야 한다. 하지만 일반적으로 클래스 A의 버전과 A를 사용하는 코드의 버전은 다르다. A를 사용하는 이전의 코드들은 여전히 a의 필드에 직접 접근한다. 따라서 전형적인 property라고 하더라도 외부에서 접근할 때 직접 field에 접근하도록 최적화 하는 것은 위험하다.

**<u> is `val` Immutable property?</u>**

`val` property는 read-only임을 나타낸다. 다시 말해, 읽을 수만 있고, 값을 재할당할 수 없다는 뜻이다.  이는 property가 불변인지 아닌지와 관련이 없다. Getter의 구현을 어떻게 하느냐에 따라 불변일수도 아닐수도 있는데 `val` property는 getter의 구현과 아무 관련이 없기 때문이다.

```kotlin
val foo : Int
    get() = Random.nextInt()

fun main() {
    println(foo)
    println(foo)
}
```

위의 예시를 보면 `foo`는 `val` 프로퍼티이다. 하지만 접근할 때마다 다른 값을 반환한다.

**<u>lateinit vs lazy</u>**

https://stackoverflow.com/questions/36623177/property-initialization-using-by-lazy-vs-lateinit

